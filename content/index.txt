---
title:      Writing Adapters for DataMapper
created_at: 2008-05-18 22:10:21.995012 -06:00
author:     Paul Sadauskas
company:    Absolute Performance, Inc
copyright:  Creative Commons
filter:
  - erb
  - maruku
  - slides
layout: presentation
---

Writing DataMapper Adapters
==================

[Paul Sadauskas][email] a.k.a [Rando][twitter]

[Absolute Performance, Inc][api]

[email]:   psadauskas@gmail.com
[twitter]: http://twitter.com/TheAmazingRando
[api]:     http://absolute-performance.com

Who the Hell are You?
==================

I'm Paul Sadauskas. Find me on the intarwebs:

 * irc:  Rando@irc.freenode.net
 * xmpp: [psadauskas@gmail.com][email]
 * www:  [TheAmazingRando.com/blog][blog]

DataMapper Hacker:

 * Designed `AbstractAdapter` API
 * Wrote initial implementation of the reference adapter, `InMemoryAdapter`

[blog]: http://theamazingrando.com/blog

WTF is DataMapper?
==================

A lightweight, modular Ruby ORM.

Powerful adapter plugins mean its not just for RDBMSs:

 * Memory
 * **Yaml files**
 * ReSTful web services
 * CouchDB
 * High-speed key-value stores (TokyoCabinet)

What Makes Up an Adapter?
==================

Just a few simple methods:

 * `initialize(name, uri_or_options)`
 * `create(resources)`
 * `read(query)`
 * `update(attributes, query)`
 * `delete(query)`

Initialize
==================

    def initialize(name, uri_or_options)
      super   # Turns uri_or_options into @options

      @path = FileUtils.mkdir_p(@options[:path])
    end

Create(resources)
==================

    def create(resources)
      resources.each do |resource|                    # 1
        update_records(resource.model) do |records|   # 2
          records[resource.key] = resource.attributes # 3
        end
      end

      resources.size                                  # 4
    end

1. resources is a collection of DM::Resource objects
2. `#update_records` is a helper in yaml adapter that reads all records from 
   the file for a model, yields it to the block, then writes the result back 
   to the file.
3. Add the attributes (a Hash) for this resource to the records hash.
4. Return the number of created records. In this case, all of them.
{:handout}

Read(query)
==================

    def read(query)
      records = records_for(query.model)     # 1
      filter_records(records.values, query)  # 2
    end

1. `#records_for` reads all the records from the yaml file for this model.
   The records in this case is a Hash of `{ key => attrs }` pairs, with `key`
   being the array of keys for a record, and attrs being a hash of 
   `{property_name => value}` pairs of attributes.
2. `#filter_records` is where all the magic happens. If your data source
   doesn't have any native searching or sorting capabilities, just run your 
   records as an array of attribute hashes though this, and it will destructively
   remove all the records that don't match the query. It will also sort and limit, 
   as needed.
{:handout}

Update(attributes, query)
==================

      def update(attributes, query)
        # Translate the attributes from { Property => val }
        # to { :name => val }
        attributes = attributes.map do |p,v|
                       [ p.name, v ] 
                     end.to_hash

        update_records(query.model) do |records|
          updated = filter_records(records.values, query)
          updated.each { |r| r.update(attributes) }      # 1
          updated.size                                   # 2
        end
      end

1. Update the the records that match the query with the new attributes.
2. Return the number of records that were updated.
{:handout}

Delete(query)
==================

      def delete(query)
        update_records(query.model) do |records|
          deleted = filter_records(records.values, query).to_set
          records.delete_if { |_k,r| deleted.include?(r) } # 1
          deleted.size
        end
      end

1. Delete the records that match the query.
{:handout}

How do I Know My Adapter Works?
===============================

    describe 'DataMapper::Adapters::YamlAdapter' do
      before :all do
        @model = Heffalump
        @string_property  = @model.color
        @integer_property = @model.num_spots
      end

      it_should_behave_like 'An Adapter'
    end

Advanced Topics
==================

 * Query
   * Fields
   * Conditions
   * Order
   * Limit & Offset

Query - Fields 
==================
    
    @fields=[
      #<DataMapper::Property @model=Heffalump @name=:id>, 
      #<DataMapper::Property @model=Heffalump @name=:color>, 
      #<DataMapper::Property @model=Heffalump @name=:num_spots>, 
      #<DataMapper::Property @model=Heffalump @name=:striped>
    ]

Query - Conditions
==================

    @conditions=[
      [
        :eql, 
        #<DataMapper::Property @model=Heffalump @name=:id>, 
        4
      ]
    ]

Query - Conditions (Next)
==================

    @conditions=
      #<DataMapper::Conditions::AndOperation
        @operands=[
          #<DataMapper::Conditions::EqualToComparison
            @property=#<DataMapper::Property @model=Heffalump @name=:id>, 
            @value=4
          >
        ]
      >

Query - Order
==================

    @order=[
      #<DataMapper::Query::Direction:0xb792e804 
        @direction=:asc, 
        @property=#<DataMapper::Property @model=Heffalump @name=:id>
      >
    ]

Query - Limit & Offset
==================

    @limit=20 
    @offset=40

The End
==================

 ~ fin ~



{:handout: class=handout}
